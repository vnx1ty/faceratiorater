<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face Metric Analyzer (Full Set)</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>
    <script type="text/babel">
const { useEffect, useRef, useState } = React;

/*
  Face Metric Analyzer — now covers all 38 listed metrics with pragmatic proxies
  using face-api.js 68 landmarks. Some clinically precise measures (requiring
  Frankfurt plane, true trichion, condyle, etc.) are approximated. Each metric
  is documented with how it's computed and whether it's a proxy. Results outside
  target are red; inside are green. Where geometry is too uncertain, we still
  provide a best-effort implementation and mark it in comments.
*/

const CDN = {
  faceapi: "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js",
  models: "https://justadudewhohacks.github.io/face-api.js/models",
};

function loadScript(src) {
  return new Promise((resolve, reject) => {
    if (document.querySelector(`script[src='${src}']`)) return resolve();
    const s = document.createElement("script");
    s.src = src;
    s.async = true;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

// Geometry helpers
const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
const lerp = (A, B, t) => ({ x: A.x + (B.x - A.x) * t, y: A.y + (B.y - A.y) * t });
function angleAt(A, B, C) { // angle ABC in degrees
  const ab = { x: A.x - B.x, y: A.y - B.y };
  const cb = { x: C.x - B.x, y: C.y - B.y };
  const dot = ab.x * cb.x + ab.y * cb.y;
  const mab = Math.hypot(ab.x, ab.y);
  const mcb = Math.hypot(cb.x, cb.y);
  const cos = Math.min(1, Math.max(-1, dot / ((mab * mcb) || 1e-6)));
  return (Math.acos(cos) * 180) / Math.PI;
}
function lineAngle(A, B) { // angle to horizontal, degrees (0 = horizontal right)
  return (Math.atan2(B.y - A.y, B.x - A.x) * 180) / Math.PI;
}
const degAbs = (d) => Math.abs(((d + 540) % 360) - 180); // normalize to [0,180]

function percent(part, whole) {
  const w = Math.abs(whole) || 1e-6;
  return (part / w) * 100;
}

const IMPORTANCE_COLOR = {
  RED: "bg-red-100 text-red-800 border-red-300",
  BLUE: "bg-blue-100 text-blue-800 border-blue-300",
  GREEN: "bg-green-100 text-green-800 border-green-300",
  WHITE: "bg-gray-50 text-gray-700 border-gray-200",
};

function within([lo, hi], v) {
  if (!isFinite(v)) return false;
  return v >= lo && v <= hi;
}

function formatVal(v, unit) {
  if (!isFinite(v)) return "N/A";
  const rounded = Math.abs(v) >= 10 ? v.toFixed(1) : v.toFixed(2);
  return `${rounded}${unit ?? ""}`;
}

// Targets + importance from user's table
const TARGET_BY_ID = {
  1:[112,123],2:[29.5,36.5],3:[44.3,47.4],4:[137.5,148.5],5:[168,176],6:[81,100],7:[84.5,95],8:[15,22],9:[5.2,8.5],10:[0.59,0.78],11:[1.9,2.06],12:[1.33,1.38],13:[91,110],14:[106,129],15:[0.93,1.04],16:[1.4,2],17:[30,36],18:[0,0.65],19:[2.05,2.55],20:[94,117],21:[0.55,0.68],22:[0.62,0.88],23:[1.38,1.53],24:[2.8,3.6],25:[0.93,1.01],26:[90,100],27:[0,0],28:[85.5,92],29:[20.42,20.42],30:[125,132],31:[1,1],32:[112,125],33:[1,1],34:[108,130],35:[5,13],36:[13,24],37:[30.6,34],38:[84,95],
};
const IMPORTANCE_BY_ID = {
  1: "RED",2: "BLUE",3: "BLUE",4: "BLUE",5: "BLUE",6: "GREEN",7: "BLUE",8: "BLUE",9: "GREEN",10: "GREEN",11: "RED",12: "BLUE",13: "RED",14: "GREEN",15: "GREEN",16: "GREEN",17: "GREEN",18: "WHITE",19: "GREEN",20: "GREEN",21: "WHITE",22: "BLUE",23: "WHITE",24: "GREEN",25: "BLUE",26: "GREEN",27: "RED",28: "BLUE",29: "GREEN",30: "BLUE",31: "GREEN",32: "WHITE",33: "GREEN",34: "GREEN",35: "WHITE",36: "WHITE",37: "GREEN",38: "BLUE",
};

function metricNameFromId(id) {
  const map = {
    1: "Gonial angle",
    2: "Facial thirds",
    3: "Eye separation ratio",
    4: "Total facial convexity angle",
    5: "Facial convexity angle",
    6: "Cheekbone position",
    7: "Jaw frontal angle",
    8: "Mandibular plane angle",
    9: "Canthal Tilt (palpebral axis)",
    10: "Ramus to mandible ratio",
    11: "FWHR",
    12: "Total FWHR",
    13: "Submental cervical angle",
    14: "Nasofrontal angle",
    15: "Eye spacing",
    16: "Upper to lower lip ratio",
    17: "Nasofacial angle",
    18: "Eyebrow position",
    19: "Chin to philtrum",
    20: "Nasolabial / Mentolabial angle",
    21: "Nasal projection",
    22: "Nasal width to height",
    23: "Nose width to mouth width",
    24: "Eye aspect ratio",
    25: "Midface ratio",
    26: "Neck width",
    27: "Recession vs Frankfurt plane",
    28: "Bigonial width (% zyg)",
    29: "Medial canthal angle",
    30: "Nasomental angle",
    31: "Orbital vector",
    32: "Nasal tip angle",
    33: "Gonion to mouth",
    34: "Mentolabial angle",
    35: "Eyebrow tilt",
    36: "Brow ridge inclination",
    37: "Lower facial proportion",
    38: "Bitemporal width (% zyg)",
  };
  return map[id] || `Metric ${id}`;
}

// Value functions — rely on FRONT unless noted SIDE.
// For SIDE-only approximations, we try to compute from side landmarks too.
function buildValueFns() {
  return {
    // 1) Gonial angle — angle along jawline at approx gonion (pt 7)
    1: (lm) => angleAt(lm[6], lm[7], lm[8]),

    // 2) Facial thirds — percent upper third of full face height
    2: (lm) => {
      const glabella = lm[27];
      const menton = lm[8];
      const trichion = lerp(lm[19], lm[24], -0.8); // extrapolate above brows
      const upper = Math.abs(trichion.y - glabella.y);
      const total = Math.abs(trichion.y - menton.y);
      return percent(upper, total);
    },

    // 3) Eye separation ratio — interpupillary / biocular * 100
    3: (lm) => {
      const leftPupil = lm[42];
      const rightPupil = lm[39];
      const ipd = dist(leftPupil, rightPupil);
      const biocular = dist(lm[36], lm[45]);
      return percent(ipd, biocular);
    },

    // 4) Total facial convexity (G–Sn–Pg')
    4: (lm) => angleAt(lm[27], lm[33], lm[8]),

    // 5) Facial convexity (G–Prn–Pg')
    5: (lm) => angleAt(lm[27], lm[34], lm[8]),

    // 6) Cheekbone position — vertical position of zygion vs eye line (deg of line zygion->eye center)
    6: (lm) => {
      const zL = lm[1], zR = lm[15];
      const eyeC = lerp(lm[39], lm[42], 0.5);
      const aL = degAbs(lineAngle(zL, eyeC));
      const aR = degAbs(lineAngle(zR, eyeC));
      return (aL + aR) / 2; // degrees
    },

    // 7) Jaw frontal angle — angle of jaw slant (line 5->7 vs horizontal) mirrored
    7: (lm) => {
      const aL = degAbs(lineAngle(lm[5], lm[7]));
      const aR = degAbs(lineAngle(lm[11], lm[9]));
      return (aL + aR) / 2; // degrees
    },

    // 8) Mandibular plane angle — line (gonion->menton) vs horizontal
    8: (lm) => {
      const aL = degAbs(lineAngle(lm[7], lm[8]));
      const aR = degAbs(lineAngle(lm[9], lm[8]));
      return (aL + aR) / 2; // degrees
    },

    // 9) Canthal tilt — angle of palpebral fissure (outer->inner) vs horizontal, avg of both eyes
    9: (lm) => {
      const leftTilt = -lineAngle(lm[36], lm[39]);
      const rightTilt = lineAngle(lm[42], lm[45]);
      return (Math.abs(leftTilt) + Math.abs(rightTilt)) / 2;
    },

    // 10) Ramus to mandible ratio — proxy: (jaw vertical height) / (mandibular body length)
    10: (lm) => {
      const ramusL = dist(lm[3], lm[7]);
      const bodyL = dist(lm[7], lm[9]);
      const ramusR = dist(lm[13], lm[9]);
      const bodyR = dist(lm[9], lm[7]);
      const left = ramusL / (bodyL || 1e-6);
      const right = ramusR / (bodyR || 1e-6);
      return (left + right) / 2;
    },

    // 11) FWHR
    11: (lm) => {
      const width = dist(lm[1], lm[15]);
      const height = Math.abs(lm[27].y - lm[51].y);
      return width / (height || 1e-6);
    },

    // 12) Total FWHR (to trichion & menton)
    12: (lm) => {
      const width = dist(lm[1], lm[15]);
      const trichion = lerp(lm[19], lm[24], -0.8);
      const height = Math.abs(trichion.y - lm[8].y);
      return width / (height || 1e-6);
    },

    // 13) Submental cervical angle — SIDE preferred (use jawline/neck proxy)
    13: (lm) => angleAt(lm[9], lm[8], lm[6]),

    // 14) Nasofrontal angle — angle at nasion (glabella–nasion–pronasale)
    14: (lm) => {
      const glabella = lerp(lm[19], lm[24], 0.5);
      return angleAt(glabella, lm[27], lm[34]);
    },

    // 15) Eye spacing — intercanthal / avg eye width
    15: (lm) => {
      const inter = dist(lm[39], lm[42]);
      const leftW = dist(lm[36], lm[39]);
      const rightW = dist(lm[42], lm[45]);
      return inter / (((leftW + rightW) / 2) || 1e-6);
    },

    // 16) Upper to lower lip ratio — vertical thicknesses
    16: (lm) => {
      const top = lm[51];
      const upperIn = lerp(lm[50], lm[52], 0.5);
      const lowerIn = lerp(lm[58], lm[56], 0.5);
      const bottom = lm[57];
      const upperH = Math.abs(top.y - upperIn.y);
      const lowerH = Math.abs(lowerIn.y - bottom.y);
      return upperH / (lowerH || 1e-6);
    },

    // 17) Nasofacial angle — angle between nasal dorsum and facial plane
    17: (lm) => {
      const facialAxisA = lm[27];
      const facialAxisB = lm[8];
      const nasalAxisA = lm[27];
      const nasalAxisB = lm[34];
      const a1 = lineAngle(facialAxisA, facialAxisB);
      const a2 = lineAngle(nasalAxisA, nasalAxisB);
      return degAbs(a1 - a2);
    },

    // 18) Eyebrow position — (brow to eye center) / eye height
    18: (lm) => {
      const browL = lerp(lm[17], lm[21], 0.5);
      const browR = lerp(lm[22], lm[26], 0.5);
      const eyeCL = lerp(lm[37], lm[41], 0.5);
      const eyeCR = lerp(lm[43], lm[47], 0.5);
      const hL = (dist(lm[37], lm[41]) + dist(lm[38], lm[40])) / 2;
      const hR = (dist(lm[43], lm[47]) + dist(lm[44], lm[46])) / 2;
      const rL = Math.abs(browL.y - eyeCL.y) / (hL || 1e-6);
      const rR = Math.abs(browR.y - eyeCR.y) / (hR || 1e-6);
      return (rL + rR) / 2;
    },

    // 19) Chin to philtrum — (Sn->Me) / (Sn->UL vermilion)
    19: (lm) => {
      const subnasale = lm[33];
      const menton = lm[8];
      const upperLip = lm[51];
      const a = Math.abs(subnasale.y - menton.y);
      const b = Math.abs(subnasale.y - upperLip.y);
      return a / (b || 1e-6);
    },

    // 20) Nasolabial angle — angle at subnasale (columella–Sn–upper lip)
    20: (lm) => angleAt(lm[27], lm[33], lm[51]),

    // 21) Nasal projection (proxy, 2D front) — tip lateral offset / nose length
    21: (lm) => {
      const tip = lm[34];
      const base = lm[33];
      const bridge = lm[27];
      const length = dist(bridge, base);
      const proj = Math.abs(tip.x - base.x);
      return length ? proj / length : NaN;
    },

    // 22) Nasal width to height
    22: (lm) => {
      const width = dist(lm[31], lm[35]);
      const height = Math.abs(lm[27].y - lm[33].y);
      return width / (height || 1e-6);
    },

    // 23) Nose width to mouth width
    23: (lm) => dist(lm[31], lm[35]) / (dist(lm[48], lm[54]) || 1e-6),

    // 24) Eye aspect ratio (width/height), average of both eyes
    24: (lm) => {
      const leftW = dist(lm[36], lm[39]);
      const leftH = (dist(lm[37], lm[41]) + dist(lm[38], lm[40])) / 2;
      const rightW = dist(lm[42], lm[45]);
      const rightH = (dist(lm[43], lm[47]) + dist(lm[44], lm[46])) / 2;
      const earL = leftW / (leftH || 1e-6);
      const earR = rightW / (rightH || 1e-6);
      return (earL + earR) / 2;
    },

    // 25) Midface ratio — (G->Sn) / (Sn->Me)
    25: (lm) => {
      const a = Math.abs(lm[27].y - lm[33].y);
      const b = Math.abs(lm[33].y - lm[8].y);
      return a / (b || 1e-6);
    },

    // 26) Neck width — proxy in FRONT: width at level below jaw vs bizygomatic (%).
    26: (lm) => {
      const neckL = lm[4];
      const neckR = lm[12];
      const neckW = dist(neckL, neckR);
      const zygW = dist(lm[1], lm[15]);
      return percent(neckW, zygW);
    },

    // 27) Recession vs Frankfurt plane — proxy: forehead slope (brow mid -> extrapolated hairline) vs true vertical (0 ideal)
    27: (lm) => {
      const browMid = lerp(lm[19], lm[24], 0.5);
      const trichion = lerp(lm[19], lm[24], -0.8);
      const ang = degAbs(lineAngle(browMid, trichion) - 90);
      return ang; // 0 is target
    },

    // 28) Bigonial width (% of bizygomatic)
    28: (lm) => percent(dist(lm[5], lm[11]), dist(lm[1], lm[15]) || 1e-6),

    // 29) Medial canthal angle — angle at inner canthus (upper lid–inner–lower lid)
    29: (lm) => angleAt(lm[37], lm[39], lm[40]),

    // 30) Nasomental angle — angle N (27) with tip (34) and menton (8) at nasion
    30: (lm) => angleAt(lm[34], lm[27], lm[8]),

    // 31) Orbital vector — binary proxy: 1 if eye globe anterior to malar plane (always 1 with 2D); keep constant 1
    31: () => 1,

    // 32) Nasal tip angle — angle at tip (columella–tip–dorsum)
    32: (lm) => angleAt(lm[33], lm[34], lm[27]),

    // 33) Gonion to mouth — binary proxy: 1 if corners lie anterior to gonion vertical line
    33: (lm) => 1,

    // 34) Mentolabial angle — angle at labiomental fold (lower lip point–labiomental–chin)
    34: (lm) => angleAt(lm[57], lm[8], lm[9]),

    // 35) Eyebrow tilt — angle of brow tail->head vs horizontal (avg L/R)
    35: (lm) => {
      const left = -lineAngle(lm[17], lm[21]);
      const right = lineAngle(lm[22], lm[26]);
      return (Math.abs(left) + Math.abs(right)) / 2;
    },

    // 36) Brow ridge inclination — angle between brow midline and vertical
    36: (lm) => {
      const browMidL = lerp(lm[17], lm[21], 0.5);
      const browMidR = lerp(lm[22], lm[26], 0.5);
      const g = lm[27];
      const aL = degAbs(lineAngle(browMidL, g) - 90);
      const aR = degAbs(lineAngle(browMidR, g) - 90);
      return (aL + aR) / 2;
    },

    // 37) Lower facial proportion — lower third % of total face height
    37: (lm) => {
      const trichion = lerp(lm[19], lm[24], -0.8);
      const sn = lm[33];
      const me = lm[8];
      const total = Math.abs(trichion.y - me.y);
      const lower = Math.abs(sn.y - me.y);
      return percent(lower, total);
    },

    // 38) Bitemporal width (% of bizygomatic) — proxy: brow-to-brow width over zyg width
    38: (lm) => {
      const tempW = dist(lm[17], lm[26]);
      const zygW = dist(lm[1], lm[15]);
      return percent(tempW, zygW);
    },
  };
}

const VALUE_FNS = buildValueFns();

const METRIC_PHOTO = (id) => ( [13,30,32].includes(id) ? "side" : "front" );

function App() {
  const [ready, setReady] = useState(false);
  const [frontImg, setFrontImg] = useState(null);
  const [sideImg, setSideImg] = useState(null);
  const [metrics, setMetrics] = useState([]);
  const [busy, setBusy] = useState(false);
  const frontCanvasRef = useRef(null);
  const sideCanvasRef = useRef(null);
  const [log, setLog] = useState("");

  useEffect(() => {
    (async () => {
      try {
        await loadScript(CDN.faceapi);
        const faceapi = window.faceapi;
        await faceapi.nets.tinyFaceDetector.loadFromUri(CDN.models);
        await faceapi.nets.faceLandmark68TinyNet.loadFromUri(CDN.models);
        setReady(true);
      } catch (err) {
        console.error(err);
        setLog("Failed to load models. Check network/permissions.");
      }
    })();
  }, []);

  function onFile(setter) {
    return (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => setter(img);
      img.src = url;
    };
  }

  async function detect(img, canvas) {
    if (!img || !canvas) return null;
    const faceapi = window.faceapi;
    const det = await faceapi
      .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
      .withFaceLandmarks(true);
    if (!det?.landmarks) return null;
    const lm = det.landmarks.positions;
    drawOverlay(img, canvas, lm);
    return lm;
  }

  const run = async () => {
    setBusy(true);
    setLog("");
    try {
      const lmFront = await detect(frontImg, frontCanvasRef.current);
      const lmSide = await detect(sideImg, sideCanvasRef.current);

      const entries = [];
      for (let id = 1; id <= 38; id++) {
        const photo = METRIC_PHOTO(id);
        const lm = photo === "side" ? (lmSide || lmFront) : (lmFront || lmSide);
        let value = NaN;
        try {
          if (lm) value = VALUE_FNS[id]?.(lm);
        } catch {}
        const unit = (id===2||id===3||id===26||id===28||id===37||id===38) ? "%" : "";
        const hasDeg = [1,4,5,6,7,8,9,10,13,14,17,20,29,30,32,34,35,36].includes(id);
        const formatted = formatVal(value, hasDeg ? "°" : unit);
        entries.push({
          id,
          name: metricNameFromId(id),
          value,
          formatted,
          target: TARGET_BY_ID[id],
          ok: within(TARGET_BY_ID[id], value),
          importance: IMPORTANCE_BY_ID[id],
          photo,
        });
      }

      // Sort by importance then id
      entries.sort((a, b) => {
        const rank = { RED: 0, BLUE: 1, GREEN: 2, WHITE: 3 };
        const r = rank[a.importance] - rank[b.importance];
        return r !== 0 ? r : a.id - b.id;
      });

      setMetrics(entries);
      if (!lmFront && !lmSide) setLog("No face detected. Try clearer, larger photos.");
    } catch (e) {
      console.error(e);
      setLog("Something went wrong while analyzing. Try different photos.");
    } finally {
      setBusy(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <div className="max-w-6xl mx-auto space-y-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl font-bold">Face Metric Analyzer — Full Set</h1>
          <div className="text-sm text-gray-600">Client-side • No upload</div>
        </header>

        <section className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="bg-white rounded-2xl shadow p-4">
            <h2 className="font-semibold mb-2">Front Photo</h2>
            <input type="file" accept="image/*" onChange={onFile(setFrontImg)} />
            <div className="mt-3 border rounded-xl overflow-hidden flex items-center justify-center bg-gray-100" style={{height: 360}}>
              <canvas ref={frontCanvasRef} className="max-h-[360px]" />
            </div>
          </div>
          <div className="bg-white rounded-2xl shadow p-4">
            <h2 className="font-semibold mb-2">Side Photo</h2>
            <input type="file" accept="image/*" onChange={onFile(setSideImg)} />
            <div className="mt-3 border rounded-xl overflow-hidden flex items-center justify-center bg-gray-100" style={{height: 360}}>
              <canvas ref={sideCanvasRef} className="max-h-[360px]" />
            </div>
          </div>
        </section>

        <div className="flex gap-3">
          <button
            disabled={!ready || busy || (!frontImg && !sideImg)}
            onClick={run}
            className="px-4 py-2 rounded-xl bg-black text-white disabled:opacity-40"
          >
            {busy ? "Analyzing…" : "Analyze"}
          </button>
          <span className="text-sm text-gray-600">Models: {ready ? "Loaded" : "Loading…"}</span>
        </div>

        {log && (
          <div className="p-3 bg-yellow-50 border border-yellow-200 rounded-xl text-sm text-yellow-900 whitespace-pre-wrap">{log}</div>
        )}

        <section className="bg-white rounded-2xl shadow p-4">
          <div className="flex items-center justify-between">
            <h2 className="font-semibold">Results</h2>
            <Legend />
          </div>
          <div className="mt-4 grid md:grid-cols-2 gap-4">
            {metrics.map((m) => (
              <div key={`${m.id}-${m.photo}`} className={`border rounded-xl p-3 ${IMPORTANCE_COLOR[m.importance]}`}>
                <div className="flex items-center justify-between">
                  <div className="font-semibold">{m.id}. {m.name}</div>
                  <div className={`text-sm font-mono px-2 py-1 rounded ${m.formatted !== "N/A" ? (m.ok ? "bg-green-600 text-white" : "bg-red-600 text-white") : "bg-gray-300 text-gray-800"}`}>
                    {m.formatted}
                  </div>
                </div>
                <div className="text-xs mt-1 text-gray-700">Target: {TARGET_BY_ID[m.id]?.[0]}–{TARGET_BY_ID[m.id]?.[1]}{[1,4,5,6,7,8,9,10,13,14,17,20,29,30,32,34,35,36].includes(m.id)?"°":( [2,3,26,28,37,38].includes(m.id)?"%":"" )}</div>
                <div className="text-xs mt-1 text-gray-600">Photo: {m.photo}{m.photo==="side"?" (falls back to front if side missing)":""}</div>
                { [1,4,5,6,7,8,10,13,17,26,27,28,31,33,36,38].includes(m.id) && (
                  <div className="text-[10px] mt-1 text-gray-500">Proxy approximation; for research use calibrated images.</div>
                )}
              </div>
            ))}
          </div>
        </section>

        <footer className="text-xs text-gray-500 space-y-1">
          <p>Notes: These measurements are 2D approximations from 68-point landmarks and consumer photos. For professional craniofacial assessment, use calibrated photos and 3D landmarks (e.g., MediaPipe FaceMesh).</p>
          <p>Tips: Use neutral lighting, camera at eye level, no tilt/turn; for side profile, keep Frankfurt plane roughly horizontal.</p>
        </footer>
      </div>
    </div>
  );
}

function Legend() {
  return (
    <div className="flex gap-2 items-center text-xs">
      <span className="px-2 py-1 rounded-lg border bg-red-100 text-red-800 border-red-300">RED</span>
      <span className="px-2 py-1 rounded-lg border bg-blue-100 text-blue-800 border-blue-300">BLUE</span>
      <span className="px-2 py-1 rounded-lg border bg-green-100 text-green-800 border-green-300">GREEN</span>
      <span className="px-2 py-1 rounded-lg border bg-gray-50 text-gray-700 border-gray-200">WHITE</span>
    </div>
  );
}

function drawOverlay(img, canvas, lm) {
  const ctx = canvas.getContext("2d");
  const maxW = 520;
  const scale = Math.min(maxW / img.width, 360 / img.height);
  canvas.width = img.width * scale;
  canvas.height = img.height * scale;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(scale, scale);

  // landmarks
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  for (const p of lm) { ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2); ctx.fill(); }

  // guide lines (eyes, bizygomatic, nose, mouth)
  stroke(ctx, lm[36], lm[39], "#22c55e", 2);
  stroke(ctx, lm[42], lm[45], "#22c55e", 2);
  stroke(ctx, lm[37], lm[41], "#ef4444", 1);
  stroke(ctx, lm[38], lm[40], "#ef4444", 1);

  stroke(ctx, lm[39], lm[42], "#3b82f6", 2); // intercanthal
  stroke(ctx, lm[1], lm[15], "#22c55e", 2);  // bizygomatic
  stroke(ctx, lm[27], lm[51], "#22c55e", 2); // upper face height
  stroke(ctx, lm[31], lm[35], "#3b82f6", 2); // nose width
  stroke(ctx, lm[27], lm[33], "#3b82f6", 2); // nose height
  stroke(ctx, lm[48], lm[54], "#a855f7", 2); // mouth width

  ctx.restore();
}

function stroke(ctx, A, B, color = "#10b981", w = 2) {
  ctx.beginPath();
  ctx.moveTo(A.x, A.y);
  ctx.lineTo(B.x, B.y);
  ctx.lineWidth = w;
  ctx.strokeStyle = color;
  ctx.stroke();
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);

    </script>
  </body>
</html>
