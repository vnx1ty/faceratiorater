<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Face Metric Analyzer (FaceMesh)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- MediaPipe FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  <script type="text/babel">
const { useEffect, useRef, useState } = React;

// ---------- Helpers ----------
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function angleAt(A,B,C){
  const ab={x:A.x-B.x,y:A.y-B.y}, cb={x:C.x-B.x,y:C.y-B.y};
  const dot=ab.x*cb.x+ab.y*cb.y, ma=Math.hypot(ab.x,ab.y), mc=Math.hypot(cb.x,cb.y);
  const cos=Math.min(1,Math.max(-1,dot/((ma*mc)||1e-6)));
  return Math.acos(cos)*180/Math.PI;
}
function deg(v){ return v*180/Math.PI; }
function rad(v){ return v*Math.PI/180; }
function lineAngle(A,B){ return Math.atan2(B.y-A.y,B.x-A.x); }
function project(a,b,p){ // projection of p onto line ab (returns point)
  const ap={x:p.x-a.x,y:p.y-a.y}, ab={x:b.x-a.x,y:b.y-a.y};
  const t=((ap.x*ab.x+ap.y*ab.y)/((ab.x*ab.x+ab.y*ab.y)||1e-6));
  return {x:a.x+ab.x*t,y:a.y+ab.y*t};
}
function within(range,v){ return Number.isFinite(v) && v>=range[0] && v<=range[1]; }
function fmt(v,unit=''){ if(!Number.isFinite(v)) return 'N/A'; const r=Math.abs(v)>=10?v.toFixed(1):v.toFixed(2); return r+unit; }

// FaceMesh landmark indices (subset)
const L = {
  // Eyes
  L_OUT: 33, L_IN: 133, R_IN: 362, R_OUT: 263,
  L_TOP: 159, L_BOT: 145, R_TOP: 386, R_BOT: 374,
  L_BROW_IN: 70, L_BROW_OUT: 105, R_BROW_IN: 336, R_BROW_OUT: 334,
  // Iris (when refineLandmarks true)
  L_IRIS: 468, R_IRIS: 473,
  // Nose / midline
  NOSE_TIP: 1, SUBNASALE: 2, NASION: 168, RHINION: 6,
  // Mouth
  M_LEFT: 61, M_RIGHT: 291, M_UP: 13, M_LOW: 14,
  // Chin & face bounds
  MENTON: 152, FOREHEAD: 10,
  // Cheekbones (zygon-ish)
  ZYG_L: 234, ZYG_R: 454,
  // Temples (bitemporal approx)
  TEMP_L: 127, TEMP_R: 356,
  // Jaw corners approx for bigonial/gonial proxies
  GONIAL_L: 172, GONIAL_R: 397,
  // Neck/throat proxies (very rough; FaceMesh has no neck)
  NECK_A: 200, NECK_B: 199,
};

// Targets
const T = {
  1:[112,123],2:[29.5,36.5],3:[44.3,47.4],4:[137.5,148.5],5:[168,176],6:[81,100],7:[84.5,95],8:[15,22],9:[5.2,8.5],10:[0.59,0.78],
  11:[1.9,2.06],12:[1.33,1.38],13:[91,110],14:[106,129],15:[0.93,1.04],16:[1.4,2],17:[30,36],18:[0,0.65],19:[2.05,2.55],20:[94,117],
  21:[0.55,0.68],22:[0.62,0.88],23:[1.38,1.53],24:[2.8,3.6],25:[0.93,1.01],26:[90,100],27:[0,0],28:[85.5,92],29:[20.42,20.42],30:[125,132],
  31:[1,1],32:[112,125],33:[1,1],34:[108,130],35:[5,13],36:[13,24],37:[30.6,34],38:[84,95],
};
const IMP = {RED:3,BLUE:2,GREEN:1,WHITE:0.5};
const IMP_BY_ID = {1:'RED',2:'BLUE',3:'BLUE',4:'BLUE',5:'BLUE',6:'GREEN',7:'BLUE',8:'BLUE',9:'GREEN',10:'GREEN',11:'RED',12:'BLUE',
                   13:'RED',14:'GREEN',15:'GREEN',16:'GREEN',17:'GREEN',18:'WHITE',19:'GREEN',20:'GREEN',21:'WHITE',22:'BLUE',
                   23:'WHITE',24:'GREEN',25:'BLUE',26:'GREEN',27:'RED',28:'BLUE',29:'GREEN',30:'BLUE',31:'GREEN',32:'WHITE',
                   33:'GREEN',34:'GREEN',35:'WHITE',36:'WHITE',37:'GREEN',38:'BLUE'};

function App(){
  const [front, setFront] = useState(null);
  const [side, setSide] = useState(null);
  const cFront = useRef(null);
  const cSide = useRef(null);
  const [metrics, setMetrics] = useState([]);
  const [overall, setOverall] = useState(null);
  const [busy, setBusy] = useState(false);
  const [log, setLog] = useState('');

  function pickFile(setter){
    return e=>{
      const f=e.target.files?.[0]; if(!f) return;
      const url=URL.createObjectURL(f);
      const img=new Image();
      img.onload=()=> setter(img);
      img.src=url;
    };
  }

  async function run(){
    setBusy(true); setLog('');
    try{
      const f = await analyzeOne(front, cFront.current, 'front');
      const s = await analyzeOne(side, cSide.current, 'side');
      const out=[];

      if(f){ out.push(...computeAllMetrics(f, 'front')); } else if(front){ setLog(l=>l+'\\nNo face detected in front photo.'); }
      if(s){ out.push(...computeAllMetrics(s, 'side')); } else if(side){ setLog(l=>l+'\\nNo face detected in side photo.'); }

      // dedupe by id keeping best (prefer front for front metrics, side for angles)
      const map=new Map();
      for(const m of out){
        if(!map.has(m.id)) map.set(m.id, m);
        else {
          const cur=map.get(m.id);
          // prefer non-NaN
          if(!Number.isFinite(cur.value) && Number.isFinite(m.value)) map.set(m.id,m);
          // or prefer front for front metrics
          else if(cur.photo!=='front' && m.photo==='front') map.set(m.id,m);
        }
      }
      // add placeholders for missing ids
      const ALL=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38];
      for(const id of ALL){
        if(!map.has(id)){
          map.set(id, {id, name:idName(id), value:NaN, unit:'', target:T[id], ok:false, importance:IMP_BY_ID[id]||'WHITE', photo: idPhoto(id), overlays:[]});
        }
      }
      const arr=[...map.values()];
      const order={RED:0,BLUE:1,GREEN:2,WHITE:3};
      arr.sort((a,b)=> (order[a.importance]-order[b.importance]) || (a.id-b.id));

      // overall weighted
      const valid = arr.filter(m=>Number.isFinite(m.value));
      const tot = valid.reduce((s,m)=> s+(IMP[m.importance]||1), 0);
      const okw = valid.reduce((s,m)=> s+((within(m.target??[0,0],m.value)?1:0)*(IMP[m.importance]||1)), 0);
      const score = tot>0 ? Math.max(0, Math.min(10, (okw/tot)*10)) : null;
      setOverall(score);
      setMetrics(arr);

      // draw overlays for each canvas by metric overlays
      if(f) drawMetricOverlays(cFront.current.getContext('2d'), f, arr.filter(m=>m.photo==='front'));
      if(s) drawMetricOverlays(cSide.current.getContext('2d'), s, arr.filter(m=>m.photo==='side'));

    }catch(e){ console.error(e); setLog('Error: '+e.message); }
    finally{ setBusy(false); }
  }

  return (
    <div className="max-w-6xl mx-auto p-6 space-y-6">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Face Metric Analyzer — FaceMesh</h1>
        <div className="text-sm text-gray-600">Client-side • No API key</div>
      </header>

      <section className="grid md:grid-cols-2 gap-6">
        <div className="bg-white rounded-xl shadow p-4">
          <h2 className="font-semibold mb-2">Front Photo</h2>
          <input type="file" accept="image/*" onChange={pickFile(setFront)} />
          <canvas ref={cFront} className="mt-3 w-full rounded-xl border bg-gray-100" style={{height:360}}/>
        </div>
        <div className="bg-white rounded-xl shadow p-4">
          <h2 className="font-semibold mb-2">Side / ¾ Photo</h2>
          <input type="file" accept="image/*" onChange={pickFile(setSide)} />
          <canvas ref={cSide} className="mt-3 w-full rounded-xl border bg-gray-100" style={{height:360}}/>
        </div>
      </section>

      <div className="flex items-center gap-3">
        <button onClick={run} disabled={busy || (!front && !side)} className="px-4 py-2 rounded-xl bg-black text-white disabled:opacity-40">
          {busy?'Analyzing…':'Analyze'}
        </button>
        {overall!=null && <div className="text-lg font-mono">Overall: {overall.toFixed(1)} / 10</div>}
      </div>

      {log && <div className="p-3 bg-yellow-50 border border-yellow-200 rounded-xl text-sm text-yellow-900 whitespace-pre-wrap">{log}</div>}

      <section className="bg-white rounded-xl shadow p-4">
        <h2 className="font-semibold">Results</h2>
        <div className="mt-4 grid md:grid-cols-2 gap-3">
          {metrics.map(m=>(
            <div key={m.id} className="border rounded-xl p-3">
              <div className="flex items-center justify-between">
                <div className="font-semibold">{m.id}. {m.name}</div>
                <div className={"text-sm font-mono px-2 py-1 rounded " + (Number.isFinite(m.value) ? (within(m.target??[0,0], m.value)?'bg-green-600 text-white':'bg-red-600 text-white') : 'bg-gray-300 text-gray-800')}>
                  {fmt(m.value, m.unit)}
                </div>
              </div>
              <div className="text-xs mt-1 text-gray-700">Target: {T[m.id]?.[0]}–{T[m.id]?.[1]}{m.unit||''}</div>
              <div className="text-xs mt-1 text-gray-500">Photo: {m.photo}</div>
            </div>
          ))}
        </div>
      </section>

      <footer className="text-xs text-gray-500">
        Notes: Several craniofacial angles are approximations from 2D projections of FaceMesh 3D landmarks and work best with well-lit, centered, non-extreme poses.
      </footer>
    </div>
  );
}

// ---------- Analysis + Drawing ----------
async function analyzeOne(img, canvas, kind){
  if(!img || !canvas) return null;
  // run FaceMesh once
  const fm=new FaceMesh({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
  fm.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
  const result = await new Promise((resolve)=>{
    fm.onResults(r=>resolve(r));
    const off=document.createElement('canvas');
    off.width=img.width; off.height=img.height;
    off.getContext('2d').drawImage(img,0,0);
    fm.send({image:off});
  });
  const lms=result?.multiFaceLandmarks?.[0];
  canvas.width=img.width; canvas.height=img.height;
  const ctx=canvas.getContext('2d');
  ctx.drawImage(img,0,0,canvas.width,canvas.height);
  if(!lms) return null;
  const pts=lms.map(p=>({x:p.x*img.width, y:p.y*img.height, z:p.z}));
  // draw mesh for reference
  drawConnectors(ctx, lms, FACEMESH_TESSELATION, { color:'#00000022', lineWidth:0.5 });
  return {img, canvas, ctx, pts, w:img.width, h:img.height, kind};
}

// Draw metric overlays (colored)
function drawMetricOverlays(ctx, pack, metrics){
  for(const m of metrics){
    for(const ov of (m.overlays||[])){
      ctx.save();
      ctx.lineWidth = ov.w || 2;
      ctx.strokeStyle = ov.color || '#22c55e';
      ctx.beginPath();
      ctx.moveTo(ov.a.x, ov.a.y);
      ctx.lineTo(ov.b.x, ov.b.y);
      ctx.stroke();
      if(ov.label){
        ctx.fillStyle = ov.color || '#22c55e';
        ctx.font = '12px sans-serif';
        ctx.fillText(ov.label, (ov.a.x+ov.b.x)/2+4, (ov.a.y+ov.b.y)/2+4);
      }
      ctx.restore();
    }
  }
}

// Name + default photo type
function idName(id){
  const map={1:'Gonial angle',2:'Facial thirds',3:'Eye separation ratio',4:'Total facial convexity angle',5:'Facial convexity angle',
    6:'Cheekbone position',7:'Jaw frontal angle',8:'Mandibular plane angle',9:'Canthal Tilt',10:'Ramus to mandible ratio',11:'FWHR',
    12:'Total FWHR',13:'Submental cervical angle',14:'Nasofrontal angle',15:'Eye spacing',16:'Upper to lower lip ratio',17:'Nasofacial angle',
    18:'Eyebrow position',19:'Chin to philtrum',20:'Mentolabial angle',21:'Nasal projection',22:'Nasal width to height',23:'Nose width to mouth width',
    24:'Eye aspect ratio',25:'Midface ratio',26:'Neck width',27:'Recession vs Frankfurt plane',28:'Bigonial width',29:'Medial canthal angle',
    30:'Nasomental angle',31:'Orbital vector',32:'Nasal tip angle',33:'Gonion to mouth',34:'Mentolabial angle',35:'Eyebrow tilt',36:'Brow ridge inclination',
    37:'Lower facial proportion',38:'Bitemporal width'};
  return map[id] || ('Metric '+id);
}
function idPhoto(id){ return [13,30,32].includes(id)?'side':'front'; }

// Main metric computations
function computeAllMetrics(pack, photo){
  const {pts,w,h} = pack;
  const P = (i)=>pts[i];

  const zygW = dist(P(L.ZYG_L), P(L.ZYG_R));
  const glabella = P(L.NASION);
  const upperLip = P(L.M_UP);
  const trich = P(L.FOREHEAD);
  const menton = P(L.MENTON);

  const out=[];
  function push(id,name,value,unit='',overlays=[]){
    const target=T[id]; const ok = target ? within(target,value) : false;
    out.push({id,name,value,unit,target,ok,importance:IMP_BY_ID[id]||'WHITE',photo,overlays});
  }

  // 11 FWHR
  push(11,'FWHR', zygW / Math.max(1e-6, Math.abs(glabella.y - upperLip.y)) );
  // 12 Total FWHR
  push(12,'Total FWHR', zygW / Math.max(1e-6, Math.abs(trich.y - menton.y)) );

  // 24 Eye aspect ratio
  const lW = dist(P(L.L_OUT), P(L.L_IN)), lH = dist(P(L.L_TOP), P(L.L_BOT));
  const rW = dist(P(L.R_OUT), P(L.R_IN)), rH = dist(P(L.R_TOP), P(L.R_BOT));
  push(24,'Eye aspect ratio', ((lW/(lH||1e-6))+(rW/(rH||1e-6)))/2, '', [
    {a:P(L.L_OUT),b:P(L.L_IN),color:'#22c55e',label:'L eye W'},
    {a:P(L.L_TOP),b:P(L.L_BOT),color:'#ef4444',label:'L eye H'},
    {a:P(L.R_OUT),b:P(L.R_IN),color:'#22c55e',label:'R eye W'},
    {a:P(L.R_TOP),b:P(L.R_BOT),color:'#ef4444',label:'R eye H'},
  ]);

  // 15 Eye spacing = intercanthal / avg eye width
  const inter = dist(P(L.L_IN), P(L.R_IN));
  push(15,'Eye spacing', inter / Math.max(1e-6, (lW + rW)/2), '', [
    {a:P(L.L_IN), b:P(L.R_IN), color:'#3b82f6', label:'Intercanthal'}
  ]);

  // 3 Eye separation ratio (%) using iris centers if available
  const lI = pts[L.L_IRIS] || P(L.L_IN);
  const rI = pts[L.R_IRIS] || P(L.R_IN);
  const ipd = dist(lI, rI), biocular = dist(P(L.L_OUT), P(L.R_OUT));
  push(3,'Eye separation ratio',(ipd/Math.max(1e-6,biocular))*100,'%', [
    {a:lI,b:rI,color:'#3b82f6',label:'IPD'},
    {a:P(L.L_OUT),b:P(L.R_OUT),color:'#10b981',label:'Biocular'}
  ]);

  // 23 Nose width to mouth width
  const noseW = dist(pts[49]||P(L.NOSE_TIP), pts[279]||P(L.NOSE_TIP)); // alar approx
  const mouthW = dist(P(L.M_LEFT), P(L.M_RIGHT));
  push(23,'Nose width to mouth width', noseW/Math.max(1e-6,mouthW),'',[
    {a:P(L.M_LEFT),b:P(L.M_RIGHT),color:'#9333ea',label:'Mouth W'}
  ]);

  // 22 Nasal width to height (tip->subnasale as height)
  const noseH = Math.abs(P(L.NOSE_TIP).y - P(L.SUBNASALE).y);
  push(22,'Nasal width to height', noseW/Math.max(1e-6,noseH));

  // 25 Midface ratio = (glabella->subnasale)/(subnasale->menton)
  const a = Math.abs(glabella.y - P(L.SUBNASALE).y);
  const b = Math.abs(P(L.SUBNASALE).y - menton.y);
  push(25,'Midface ratio', a/Math.max(1e-6,b), '', [
    {a:glabella,b:P(L.SUBNASALE),color:'#0ea5e9',label:'G-Sn'},
    {a:P(L.SUBNASALE),b:menton,color:'#0ea5e9',label:'Sn-Me'},
  ]);

  // 2 Facial thirds (mid % of total height)
  const totalH = Math.abs(trich.y - menton.y);
  const midPct = (Math.abs(glabella.y - P(L.SUBNASALE).y)/Math.max(1e-6,totalH))*100;
  push(2,'Facial thirds (mid %)', midPct, '%', [
    {a:trich,b:menton,color:'#6b7280',label:'Total H'}
  ]);

  // 16 Upper to lower lip ratio (approx)
  const lipH = Math.abs(P(L.M_LOW).y - P(L.M_UP).y);
  const upperH = Math.abs(P(L.M_UP).y - (P(L.M_UP))); // simplified proxy
  const ulr = (lipH>0) ? (upperH / Math.max(1e-6, lipH-upperH)) : NaN;
  push(16,'Upper to lower lip ratio', ulr );

  // 28 Bigonial width (% of zygomatic)
  const bigonial = dist(P(L.GONIAL_L), P(L.GONIAL_R));
  push(28,'Bigonial width', (bigonial/Math.max(1e-6, zygW))*100, '%', [
    {a:P(L.GONIAL_L), b:P(L.GONIAL_R), color:'#22c55e', label:'Bigonial'},
    {a:P(L.ZYG_L), b:P(L.ZYG_R), color:'#64748b', label:'Zygomatic'}
  ]);

  // 38 Bitemporal width (% of zygomatic)
  const bitemporal = dist(P(L.TEMP_L), P(L.TEMP_R));
  push(38,'Bitemporal width', (bitemporal/Math.max(1e-6, zygW))*100, '%', [
    {a:P(L.TEMP_L), b:P(L.TEMP_R), color:'#22c55e', label:'Bitemporal'}
  ]);

  // 30 Nasomental angle (approx) at nasion between nose tip and menton
  push(30,'Nasomental angle', angleAt(P(L.NOSE_TIP), P(L.NASION), menton), '°', [
    {a:P(L.NOSE_TIP), b:P(L.NASION), color:'#ef4444', label:'N-T'},
    {a:menton, b:P(L.NASION), color:'#ef4444', label:'N-Me'}
  ]);

  // 32 Nasal tip angle (approx) at tip between subnasale and nasion
  push(32,'Nasal tip angle', angleAt(P(L.SUBNASALE), P(L.NOSE_TIP), P(L.NASION)), '°', [
    {a:P(L.SUBNASALE), b:P(L.NOSE_TIP), color:'#f97316', label:'Sn-T'},
    {a:P(L.NASION), b:P(L.NOSE_TIP), color:'#f97316', label:'N-T'}
  ]);

  // 13 Submental-cervical angle (very approximate)
  push(13,'Submental cervical angle', angleAt(P(L.NECK_A), menton, P(L.NECK_B)), '°', [
    {a:P(L.NECK_A), b:menton, color:'#059669', label:'Throat'},
    {a:P(L.NECK_B), b:menton, color:'#059669', label:'Neck'}
  ]);

  // 35 Eyebrow tilt (left brow)
  const browTilt = Math.abs(deg(lineAngle(P(L.L_BROW_IN), P(L.L_BROW_OUT))));
  push(35,'Eyebrow tilt', browTilt, '°', [{a:P(L.L_BROW_IN), b:P(L.L_BROW_OUT), color:'#22c55e', label:'Brow'}]);

  // 9 Canthal tilt (left eye) outer->inner vs horizontal
  const ct = deg(lineAngle(P(L.L_OUT), P(L.L_IN)));
  push(9,'Canthal Tilt', Math.abs(ct), '°', [{a:P(L.L_OUT), b:P(L.L_IN), color:'#3b82f6', label:'Canthus'}]);

  // 11 already added; 12 added; 24,15,3 added; 22,23,25,2,16,28,38,30,32,13,35,9 added.

  // ---- The following require more robust anatomical mapping; leaving as N/A placeholders with overlays minimal ----
  const NA = (id,name)=> push(id, name, NaN);
  NA(1,'Gonial angle');
  NA(4,'Total facial convexity angle');
  NA(5,'Facial convexity angle');
  NA(6,'Cheekbone position');
  NA(7,'Jaw frontal angle');
  NA(8,'Mandibular plane angle');
  NA(10,'Ramus to mandible ratio');
  NA(14,'Nasofrontal angle');
  NA(17,'Nasofacial angle');
  NA(18,'Eyebrow position');
  NA(19,'Chin to philtrum');
  NA(20,'Mentolabial angle');
  NA(21,'Nasal projection');
  NA(26,'Neck width');
  NA(27,'Recession vs Frankfurt plane');
  NA(29,'Medial canthal angle');
  NA(31,'Orbital vector');
  NA(33,'Gonion to mouth');
  NA(34,'Mentolabial angle');
  NA(36,'Brow ridge inclination');
  NA(37,'Lower facial proportion');

  return out;
}

  </script>
</body>
</html>
