<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face Metric Analyzer — FaceMesh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- MediaPipe FaceMesh (pure JS) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useRef } = React;

      // Helper: distance in image pixels between two FaceMesh landmarks (normalized [0..1])
      function pd(a, b, w, h) {
        const dx = (a.x - b.x) * w;
        const dy = (a.y - b.y) * h;
        return Math.hypot(dx, dy);
      }

      // Angle at B (in degrees) given three points in pixel coords
      function angleAt(A, B, C) {
        const ab = { x: A.x - B.x, y: A.y - B.y };
        const cb = { x: C.x - B.x, y: C.y - B.y };
        const dot = ab.x * cb.x + ab.y * cb.y;
        const mab = Math.hypot(ab.x, ab.y);
        const mcb = Math.hypot(cb.x, cb.y);
        const cos = Math.min(1, Math.max(-1, dot / (mab * mcb || 1e-6)));
        return (Math.acos(cos) * 180) / Math.PI;
      }

      // Convenience to pick landmark and convert to pixel space
      function P(lms, idx, w, h) {
        const p = lms[idx];
        return { x: p.x * w, y: p.y * h, z: p.z };
      }

      // Known landmark indices (FaceMesh)
      const IDX = {
        // Eyes
        L_OUT: 33, L_IN: 133, R_IN: 362, R_OUT: 263,
        L_TOP: 159, L_BOT: 145, R_TOP: 386, R_BOT: 374,
        // Iris centers (need refineLandmarks true)
        L_IRIS: 468, R_IRIS: 473,
        // Mouth
        M_LEFT: 61, M_RIGHT: 291, M_UP: 13, M_LOW: 14,
        // Nose
        NOSE_TIP: 1, SUBNASALE: 2, NASION: 168,
        // Face bounds
        CHIN: 152, FOREHEAD: 10,
        ZYG_L: 234, ZYG_R: 454,    // cheekbone extremes (approx)
        TEMP_L: 127, TEMP_R: 356   // bitemporal (approx)
      };

      const TARGETS = {
        1:[112,123],2:[29.5,36.5],3:[44.3,47.4],4:[137.5,148.5],5:[168,176],6:[81,100],7:[84.5,95],8:[15,22],9:[5.2,8.5],10:[0.59,0.78],
        11:[1.9,2.06],12:[1.33,1.38],13:[91,110],14:[106,129],15:[0.93,1.04],16:[1.4,2],17:[30,36],18:[0,0.65],19:[2.05,2.55],20:[94,117],
        21:[0.55,0.68],22:[0.62,0.88],23:[1.38,1.53],24:[2.8,3.6],25:[0.93,1.01],26:[90,100],27:[0,0],28:[85.5,92],29:[20.42,20.42],30:[125,132],
        31:[1,1],32:[112,125],33:[1,1],34:[108,130],35:[5,13],36:[13,24],37:[30.6,34],38:[84,95],
      };

      const IMP = { RED:3, BLUE:2, GREEN:1, WHITE:0.5 };
      const IMP_BY_ID = {1:'RED',2:'BLUE',3:'BLUE',4:'BLUE',5:'BLUE',6:'GREEN',7:'BLUE',8:'BLUE',9:'GREEN',10:'GREEN',11:'RED',12:'BLUE',
                         13:'RED',14:'GREEN',15:'GREEN',16:'GREEN',17:'GREEN',18:'WHITE',19:'GREEN',20:'GREEN',21:'WHITE',22:'BLUE',
                         23:'WHITE',24:'GREEN',25:'BLUE',26:'GREEN',27:'RED',28:'BLUE',29:'GREEN',30:'BLUE',31:'GREEN',32:'WHITE',
                         33:'GREEN',34:'GREEN',35:'WHITE',36:'WHITE',37:'GREEN',38:'BLUE'};

      function inRange(v, [lo,hi]) { return Number.isFinite(v) && v >= lo && v <= hi; }
      function fmt(v, unit='') { if(!Number.isFinite(v)) return 'N/A'; const r = Math.abs(v)>=10 ? v.toFixed(1):v.toFixed(2); return r + unit; }

      function App(){
        const [front, setFront] = useState(null);
        const [side, setSide] = useState(null);
        const [frontLm, setFrontLm] = useState(null);
        const [sideLm, setSideLm] = useState(null);
        const [metrics, setMetrics] = useState([]);
        const [overall, setOverall] = useState(null);
        const [busy, setBusy] = useState(false);
        const [log, setLog] = useState('');
        const cFront = React.useRef(null);
        const cSide = React.useRef(null);

        function readFile(setter){
          return e => {
            const f = e.target.files?.[0]; if(!f) return;
            const url = URL.createObjectURL(f);
            const img = new Image();
            img.onload = ()=> setter(img);
            img.src = url;
          };
        }

        async function run(){
          setBusy(true); setLog('');
          try {
            const fm = new FaceMesh({
              locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });
            fm.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });

            const doOne = async (img, canvas) => {
              if(!img) return null;
              const w = img.width, h = img.height;
              canvas.width = w; canvas.height = h;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0,0,w,h);
              ctx.drawImage(img,0,0,w,h);
              let resolveRes;
              const p = new Promise(res => resolveRes = res);
              fm.onResults(res => resolveRes(res));
              await fm.send({image: img});
              const res = await p;
              const lms = res.multiFaceLandmarks?.[0];
              if(!lms){ return null; }
              // draw landmarks for debug
              drawConnectors(ctx, lms, FACEMESH_TESSELATION, { color:'#00000033', lineWidth:0.5 });
              return { lms, w, h };
            };

            const fRes = await doOne(front, cFront.current);
            const sRes = await doOne(side, cSide.current);

            setFrontLm(fRes);
            setSideLm(sRes);

            const all = [];

            // FRONT METRICS
            if(fRes){
              const {lms,w,h} = fRes;
              const Pn = (i)=>P(lms,i,w,h);
              // 11 FWHR = bizygomatic / upper face height (glabella->upper lip)
              const fzL = Pn(IDX.ZYG_L), fzR = Pn(IDX.ZYG_R);
              const glab = Pn(IDX.NASION); // approx
              const upperLip = Pn(IDX.M_UP);
              const f_width = pd(fzL,fzR,w,h);
              const f_upper_h = Math.abs(glab.y - upperLip.y);
              const FWHR = f_width / (f_upper_h||1e-6);
              all.push({id:11,name:'FWHR',value:FWHR,unit:'',photo:'front'});

              // 12 Total FWHR = bizygomatic / (trichion->menton)
              const trich = Pn(IDX.FOREHEAD), menton = Pn(IDX.CHIN);
              const totFWHR = f_width / (Math.abs(trich.y - menton.y)||1e-6);
              all.push({id:12,name:'Total FWHR',value:totFWHR,unit:'',photo:'front'});

              // 24 Eye aspect ratio (avg of both eyes)
              const l_w = pd(Pn(IDX.L_OUT), Pn(IDX.L_IN), w,h);
              const l_h = (pd(Pn(IDX.L_TOP),Pn(IDX.L_BOT),w,h));
              const r_w = pd(Pn(IDX.R_OUT), Pn(IDX.R_IN), w,h);
              const r_h = (pd(Pn(IDX.R_TOP),Pn(IDX.R_BOT),w,h));
              const EAR = ((l_w/(l_h||1e-6)) + (r_w/(r_h||1e-6)))/2;
              all.push({id:24,name:'Eye aspect ratio',value:EAR,unit:'',photo:'front'});

              // 15 Eye spacing = intercanthal / avg eye width
              const inter = pd(Pn(IDX.L_IN), Pn(IDX.R_IN), w,h);
              const avgEyeW = (l_w + r_w)/2;
              const eyeSpacing = inter / (avgEyeW||1e-6);
              all.push({id:15,name:'Eye spacing',value:eyeSpacing,unit:'',photo:'front'});

              // 3 Eye separation ratio (IPD/biocular * 100) - use iris centers if present else inner corners
              const lI = lms[IDX.L_IRIS] ? Pn(IDX.L_IRIS) : Pn(IDX.L_IN);
              const rI = lms[IDX.R_IRIS] ? Pn(IDX.R_IRIS) : Pn(IDX.R_IN);
              const ipd = pd(lI,rI,w,h);
              const biocular = pd(Pn(IDX.L_OUT),Pn(IDX.R_OUT),w,h);
              const eyeSepRatio = (ipd/(biocular||1e-6))*100;
              all.push({id:3,name:'Eye separation ratio',value:eyeSepRatio,unit:'%',photo:'front'});

              // 23 Nose width to mouth width
              const noseW = pd(Pn(49), Pn(279), w,h);
              const mouthW = pd(Pn(IDX.M_LEFT), Pn(IDX.M_RIGHT), w,h);
              all.push({id:23,name:'Nose width to mouth width',value:(noseW/(mouthW||1e-6)),unit:'',photo:'front'});

              // 22 Nasal width to height (tip->subnasale used for height proxy)
              const noseH = Math.abs(Pn(IDX.NOSE_TIP).y - Pn(IDX.SUBNASALE).y);
              all.push({id:22,name:'Nasal width to height',value:(noseW/(noseH||1e-6)),unit:'',photo:'front'});

              // 25 Midface ratio = (glabella->subnasale)/(subnasale->menton)
              const a = Math.abs(Pn(IDX.NASION).y - Pn(IDX.SUBNASALE).y);
              const b = Math.abs(Pn(IDX.SUBNASALE).y - Pn(IDX.CHIN).y);
              all.push({id:25,name:'Midface ratio',value:(a/(b||1e-6)),unit:'',photo:'front'});

              // 2 Facial thirds (percent of total height for mid third) -> map to 29.5–36.5
              const top = Pn(IDX.FOREHEAD).y, g = Pn(IDX.NASION).y, sn = Pn(IDX.SUBNASALE).y, me = Pn(IDX.CHIN).y;
              const totalH = Math.abs(top - me);
              const middleThirdPct = (Math.abs(g - sn)/(totalH||1e-6))*100;
              all.push({id:2,name:'Facial thirds (mid %)',value:middleThirdPct,unit:'',photo:'front'});

              // 16 Upper to lower lip ratio (vertical thickness)
              const upperH = Math.abs(Pn(IDX.M_UP).y - ((Pn(0)||Pn(IDX.M_UP)).y)); // simple proxy
              const lowerH = Math.abs(((Pn(IDX.M_LOW)).y) - (Pn(IDX.M_LOW).y + (Pn(IDX.M_LOW).y - Pn(IDX.M_UP).y)));
              const ulr = upperH/Math.max(1e-6, (Math.abs(Pn(IDX.M_LOW).y - Pn(IDX.M_UP).y) - upperH));
              all.push({id:16,name:'Upper to lower lip ratio',value:ulr,unit:'',photo:'front'});

              // 28 Bigonial width (proxy from jaw corners  jawline approx indices 172 and 397)
              const bigonial = pd(Pn(172), Pn(397), w,h);
              const faceW = pd(fzL,fzR,w,h);
              all.push({id:28,name:'Bigonial width (% of zygomatic)',value:(bigonial/(faceW||1e-6))*100,unit:'%',photo:'front'});

              // 38 Bitemporal width (temple-to-temple as % of zygomatic)
              const bitemporal = pd(Pn(IDX.TEMP_L), Pn(IDX.TEMP_R), w,h);
              all.push({id:38,name:'Bitemporal width (% of zygomatic)',value:(bitemporal/(faceW||1e-6))*100,unit:'%',photo:'front'});
            } else {
              setLog(s => s + "\nNo face detected in front photo.");
            }

            // SIDE/ANGLE METRICS (approx from same landmarks — best with 3/4 view)
            if(sRes){
              const {lms,w,h} = sRes;
              const Pn = (i)=>P(lms,i,w,h);

              // 30 Nasomental angle ≈ angle at nasion between nose tip and chin
              const ns = Pn(IDX.NASION), nt = Pn(IDX.NOSE_TIP), me = Pn(IDX.CHIN);
              const nma = angleAt(nt, ns, me);
              all.push({id:30,name:'Nasomental angle (approx)',value:nma,unit:'°',photo:'side'});

              // 32 Nasal tip angle ≈ angle at tip between columella (subnasale) and dorsum (nasion)
              const nta = angleAt(Pn(IDX.SUBNASALE), Pn(IDX.NOSE_TIP), Pn(IDX.NASION));
              all.push({id:32,name:'Nasal tip angle (approx)',value:nta,unit:'°',photo:'side'});

              // 13 Submental-cervical (very rough from chin–throat line): use chin(152), neck points 200/199 area
              const throat = Pn(200), neck = Pn(199);
              const sca = angleAt(throat, me, neck);
              all.push({id:13,name:'Submental cervical angle (approx)',value:sca,unit:'°',photo:'side'});

              // 35 Eyebrow tilt (left brow line) using 70-105 approx
              const browL = Pn(70), browR = Pn(105);
              const browTilt = (Math.atan2(browR.y - browL.y, browR.x - browL.x) * 180/Math.PI);
              all.push({id:35,name:'Eyebrow tilt (°)',value:Math.abs(browTilt),unit:'°',photo:'front'});

              // 9 Canthal tilt = outer->inner eye angle (left eye)
              const canthal = (Math.atan2(Pn(IDX.L_IN).y - Pn(IDX.L_OUT).y, Pn(IDX.L_IN).x - Pn(IDX.L_OUT).x) * 180/Math.PI);
              all.push({id:9,name:'Canthal tilt (°)',value:canthal,unit:'°',photo:'front'});
            } else {
              setLog(s => s + "\nNo face detected in side photo.");
            }

            // Merge target ranges and importance; compute OK flags
            const out = [];
            for(const m of all){
              const target = TARGETS[m.id];
              const ok = target ? inRange(m.value, target) : false;
              out.push({
                ...m,
                formatted: fmt(m.value, m.unit),
                target,
                ok,
                importance: IMP_BY_ID[m.id] || 'GREEN'
              });
            }

            // Add any remaining ids as N/A placeholders to keep the list complete
            const ALL_IDS = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38];
            const present = new Set(out.map(m => m.id));
            for(const id of ALL_IDS){
              if(!present.has(id)){
                out.push({id, name: idName(id), value: NaN, formatted:'N/A', unit:'', target: TARGETS[id], ok:false, importance: IMP_BY_ID[id]||'WHITE', photo: idPhoto(id)});
              }
            }

            // sort by importance then id
            const order = {RED:0,BLUE:1,GREEN:2,WHITE:3};
            out.sort((a,b)=> (order[a.importance]-order[b.importance]) || (a.id-b.id));
            setMetrics(out);

            // Overall weighted score 1..10
            const valid = out.filter(m => Number.isFinite(m.value));
            const totalW = valid.reduce((s,m)=> s + (IMP[m.importance]||1), 0);
            const okW = valid.reduce((s,m)=> s + ((m.ok?1:0) * (IMP[m.importance]||1)), 0);
            const score = totalW>0 ? Math.max(0, Math.min(10, (okW/totalW)*10)) : null;
            setOverall(score);

          } catch(err){
            console.error(err);
            setLog("Analyzer error: " + err.message);
          } finally {
            setBusy(false);
          }
        }

        function idName(id){
          const map = {
            1:'Gonial angle',2:'Facial thirds',3:'Eye separation ratio',4:'Total facial convexity angle',5:'Facial convexity angle',
            6:'Cheekbone position',7:'Jaw frontal angle',8:'Mandibular plane angle',9:'Canthal Tilt',10:'Ramus to mandible ratio',
            11:'FWHR',12:'Total FWHR',13:'Submental cervical angle',14:'Nasofrontal angle',15:'Eye spacing',16:'Upper to lower lip ratio',
            17:'Nasofacial angle',18:'Eyebrow position',19:'Chin to philtrum',20:'Mentolabial angle',21:'Nasal projection',22:'Nasal width to height',
            23:'Nose width to mouth width',24:'Eye aspect ratio',25:'Midface ratio',26:'Neck width',27:'Recession vs Frankfurt plane',
            28:'Bigonial width',29:'Medial canthal angle',30:'Nasomental angle',31:'Orbital vector',32:'Nasal tip angle',33:'Gonion to mouth',
            34:'Mentolabial angle',35:'Eyebrow tilt',36:'Brow ridge inclination',37:'Lower facial proportion',38:'Bitemporal width'
          };
          return map[id] || ('Metric ' + id);
        }
        function idPhoto(id){ return [13,30,32].includes(id) ? 'side' : 'front'; }

        return (
          <div className="max-w-6xl mx-auto p-6 space-y-6">
            <header className="flex items-center justify-between">
              <h1 className="text-2xl font-bold">Face Metric Analyzer — FaceMesh</h1>
              <div className="text-sm text-gray-600">Client-side • No API keys • 3D landmarks</div>
            </header>

            <section className="grid md:grid-cols-2 gap-6">
              <div className="bg-white rounded-2xl shadow p-4">
                <h2 className="font-semibold mb-2">Front Photo</h2>
                <input type="file" accept="image/*" onChange={readFile(setFront)} />
                <canvas ref={cFront} className="mt-3 w-full rounded-xl border bg-gray-100" style={{height:360}}></canvas>
              </div>
              <div className="bg-white rounded-2xl shadow p-4">
                <h2 className="font-semibold mb-2">Side / 3⁄4 Photo</h2>
                <input type="file" accept="image/*" onChange={readFile(setSide)} />
                <canvas ref={cSide} className="mt-3 w-full rounded-xl border bg-gray-100" style={{height:360}}></canvas>
              </div>
            </section>

            <div className="flex items-center gap-3">
              <button onClick={run} disabled={busy || (!front && !side)} className="px-4 py-2 rounded-xl bg-black text-white disabled:opacity-40">
                {busy ? 'Analyzing…' : 'Analyze'}
              </button>
              {overall!=null && <div className="text-lg font-mono">Overall: {overall.toFixed(1)} / 10</div>}
            </div>

            {log && <div className="p-3 bg-yellow-50 border border-yellow-200 rounded-xl text-sm text-yellow-900 whitespace-pre-wrap">{log}</div>}

            <section className="bg-white rounded-2xl shadow p-4">
              <h2 className="font-semibold flex items-center justify-between">Results
                <span className="text-xs text-gray-500">Green = in range, Red = out of range, Gray = not computed</span>
              </h2>
              <div className="mt-4 grid md:grid-cols-2 gap-4">
                {metrics.map(m => (
                  <div key={m.id} className="border rounded-xl p-3">
                    <div className="flex items-center justify-between">
                      <div className="font-semibold">{m.id}. {m.name}</div>
                      <div className={"text-sm font-mono px-2 py-1 rounded " + (m.formatted==='N/A' ? 'bg-gray-300 text-gray-800' : (m.ok ? 'bg-green-600 text-white' : 'bg-red-600 text-white'))}>
                        {m.formatted}
                      </div>
                    </div>
                    <div className="text-xs text-gray-600 mt-1">Target: {TARGETS[m.id]?.[0]}–{TARGETS[m.id]?.[1]}{m.unit||''}</div>
                    <div className="text-xs text-gray-500 mt-1">Photo: {m.photo}</div>
                  </div>
                ))}
              </div>
            </section>

            <footer className="text-xs text-gray-500">
              Notes: This uses MediaPipe FaceMesh (468+10 iris landmarks). A few anatomy-heavy angles are approximations and work best on well-lit, centered photos.
            </footer>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App/>);
    </script>
  </body>
</html>
